{"path":"University/АКГ/Лабораторные работы.pdf","text":"1 ЛАБОРАТОРНАЯ РАБОТА №1 1) Разработать парсер файлов формата .obj Далее будут рассмотрены основные компоненты, которые нужно прочи- тать из файла, чтобы можно было визуализировать объекты. v x y z [w] Описывает координаты геометрической вершины в трехмерном про- странстве. Данные координаты задают положение вершины в пространстве модели. Для кривых и поверхностей также указывается необязательная коор- дината w. По умолчанию она равна 1. vt u [v] [w] Описывает текстурные координаты вершины. Для одномерной текстуры требуется только координата u, для двухмерной — u и v, а для трехмерной — все три координаты. Координаты v и w необязательны и по умолчанию равны 0. Обычно текстурные координаты находятся в диапазоне от 0 до 1. Значения координат, которые выходят за этот диапазон, используются для создания по- вторяющейся текстуры. vn i j k Описывает трехмерный вектор нормали вершины. Он необходим для по- строения плавного освещения. При наличии нормали группы сглаживания иг- норируются. Вектор может быть ненормированным. f v1 v2 v3 v4 ... Описывает полигон, который должен содержать не менее трех вершин, перечисленных через пробел. В качестве параметров данная конструкция ис- пользует индексы координат вершин, прочитанных ранее. Нумерация индек- сов начинается с 1. Также индексы могут быть отрицательными. Если индекс имеет значение -1, он ссылается на последний прочитанный элемент. Вместе с индексами координат вершин могут быть записаны индексы текстурных координат: f v1/vt1 v2/vt2 v3/vt3 v4/vt4 ... Также допустимо хранение индексов вершинных нормалей: f v1/vt1/vn1 v2/vt2/vn2 v3/vt3/vn3 v4/vt4/vn4 ... Если индексы текстурных координат указывать не нужно, их можно про- пустить: f v1//vn1 v2//vn2 v3//vn3 v4//vn4 ... 2 2) Реализовать матричные преобразования координат из пространства модели в мировое пространство Так как прочитанные из файла координаты вершин находятся в про- странстве модели, перед отрисовкой их необходимо преобразовать в мировые координаты. Для этого используются матричные преобразования. Если необходимо представить преобразование из одного трехмерного пространства в другое, то понадобится матрица размером 4 × 4. В данном слу- чае будет предполагаться нотация вектора-столбца, как в OpenGL. Чтобы при- менить преобразование, нужно умножить все векторы, которые необходимо преобразовать, на матрицы преобразования. Ниже представлено общее преобразование в матричной форме: [ 𝑋𝐴𝑥𝑖𝑠. 𝑥 𝑌𝐴𝑥𝑖𝑠. 𝑥 𝑍𝐴𝑥𝑖𝑠. 𝑥 𝑇𝑟𝑎𝑛𝑠𝑙𝑎𝑡𝑖𝑜𝑛. 𝑥 𝑋𝐴𝑥𝑖𝑠. 𝑦 𝑌𝐴𝑥𝑖𝑠. 𝑦 𝑍𝐴𝑥𝑖𝑠. 𝑦 𝑇𝑟𝑎𝑛𝑠𝑙𝑎𝑡𝑖𝑜𝑛. 𝑦 𝑋𝐴𝑥𝑖𝑠. 𝑧 𝑌𝐴𝑥𝑖𝑠. 𝑧 𝑍𝐴𝑥𝑖𝑠. 𝑧 𝑇𝑟𝑎𝑛𝑠𝑙𝑎𝑡𝑖𝑜𝑛. 𝑧 0 0 0 1 ], (1.1) где 𝑋𝐴𝑥𝑖𝑠 является ориентацией оси X в новом пространстве, 𝑌𝐴𝑥𝑖𝑠 является ориентацией оси Y в новом пространстве, 𝑍𝐴𝑥𝑖𝑠 является ориентацией оси Z в новом пространстве, а 𝑇𝑟𝑎𝑛𝑠𝑙𝑎𝑡𝑖𝑜𝑛 описывает положение, в котором новое пространство будет находиться относительно активного пространства. Иногда необходимо сделать простые преобразования, такие как переме- щение или вращение. В этих случаях можно использовать следующие мат- рицы, которые являются частными случаями только что представленной об- щей формы. Матрица перемещения: [ 1 0 0 𝑇𝑟𝑎𝑛𝑠𝑙𝑎𝑡𝑖𝑜𝑛. 𝑥 0 1 0 𝑇𝑟𝑎𝑛𝑠𝑙𝑎𝑡𝑖𝑜𝑛. 𝑦 0 0 1 𝑇𝑟𝑎𝑛𝑠𝑙𝑎𝑡𝑖𝑜𝑛. 𝑧 0 0 0 1 ], (1.2) где 𝑇𝑟𝑎𝑛𝑠𝑙𝑎𝑡𝑖𝑜𝑛 — это трехмерный вектор, который представляет позицию, в которую необходимо переместить пространство. Матрица перемещения оставляет все оси повернутыми в том же направлении, что и направление осей активного пространства. 3 Матрица масштаба: [ 𝑆𝑐𝑎𝑙𝑒. 𝑥 0 0 0 0 𝑆𝑐𝑎𝑙𝑒. 𝑦 0 0 0 0 𝑆𝑐𝑎𝑙𝑒. 𝑧 0 0 0 0 1 ], (1.3) где 𝑆𝑐𝑎𝑙𝑒 — трехмерный вектор, который представляет масштаб вдоль каждой оси. Если прочитать первый столбец, можно увидеть, как новая ось X все еще находится в том же направлении, но масштабируется скалярным 𝑆𝑐𝑎𝑙𝑒. 𝑥. То же самое происходит со всеми другими осями. Также стоит обратить внимание на то, что столбец перемещения — это все нули, что означает, что перемеще- ние не требуется. Матрица поворота вокруг оси X: [ 1 0 0 0 0 cos⁡(𝜃) −sin⁡(𝜃) 0 0 sin⁡(𝜃) cos⁡(𝜃) 0 0 0 0 1 ], (1.4) где 𝜃 — угол, на который нужно повернуть вектор. Следует отметить, что пер- вый столбец никогда не изменится, так как вращение происходит вокруг оси X. Также необходимо обратить внимание на то, как изменение 𝜃 на 90° преоб- разует ось Y в ось Z и ось Z в ось Y. Матрица поворота вокруг оси Y: [ cos⁡(𝜃) 0 sin⁡(𝜃) 0 0 1 0 0 −sin⁡(𝜃) 0 cos⁡(𝜃) 0 0 0 0 1 ]. (1.5) Матрица поворота вокруг оси Z: [ cos⁡(𝜃) −sin⁡(𝜃) 0 0 sin⁡(𝜃) cos⁡(𝜃) 0 0 0 0 1 0 0 0 0 1 ]. (1.6) Матрицы вращения для оси Z и оси Y ведут себя так же, как и матрица вращения для оси X. Представленные матрицы часто используются, и все они необходимы для описания преобразований. Можно связать несколько преобразований вме- сте, умножая матрицы одну за другой. Результатом будет одиночная матрица, которая кодирует полное преобразование. Порядок, который применятся для 4 преобразований, очень важен. Это отражается в математике тем, что матрич- ное умножение не является коммутативным. Поэтому в общем случае [𝑇𝑟𝑎𝑛𝑠𝑙𝑎𝑡𝑒] × [𝑅𝑜𝑡𝑎𝑡𝑒] отличается от [𝑅𝑜𝑡𝑎𝑡𝑒] × [𝑇𝑟𝑎𝑛𝑠𝑙𝑎𝑡𝑒]. Поскольку для преобразований используются векторы-столбцы, читать цепочку преобразований следует справа налево, поэтому, если необходимо по- вернуть объект на 90° влево вокруг оси Y, а затем переместить его на 10 еди- ниц вдоль оси Z, цепочка будет следующей: [𝑇𝑟𝑎𝑛𝑠𝑙𝑎𝑡𝑒𝑋⁡10] × [𝑅𝑜𝑡𝑎𝑡𝑒𝑌⁡90°]. 3) Реализовать матричное преобразование координат из мирового пространства в пространство наблюдателя Первый шаг отображения 3D сцены — это поместить все модели в одно и то же пространство — мировое пространство. Поскольку каждый объект в мире будет иметь свое собственное положение и ориентацию, у каждого из них есть своя матрица трансформации. Затем каждый объект нужно спроецировать на экран. Обычно это дела- ется в два этапа. Первый шаг перемещает весь объект в другое пространство, называемое пространством наблюдателя. Второй шаг выполняет фактическую проекцию с использованием матрицы проекции. Пространство наблюдателя — это вспомогательное пространство, кото- рое используется для упрощения математики. Идея состоит в том, чтобы рас- положить все объекты относительно камеры, предполагая проецирование всех их вершин на экран камеры, который может быть произвольно ориентирован в пространстве. Математика сильно бы упростилась, если бы была возмож- ность сосредоточить камеру в начале координат и направить ее в сторону од- ной из трех осей, например, оси Z. Таким образом, происходит переход из ми- рового пространства в пространство наблюдателя (иногда называемое про- странством камеры). Теперь, если необходимо поместить камеру в мировое пространство, нужно использовать матрицу преобразования, которая находится там, где находится камера, и ориентирована так, что ось Z смотрит на цель камеры. Обратное преобразование, применяемое ко всем объектам в мировом про- странстве, переместит весь мир в пространство наблюдателя. Следует обра- тить внимание на то, что можно объединить две трансформации из простран- ства модели в мировое пространство и из мирового пространства в простран- ство наблюдателя в единое преобразование из пространства модели в про- странство наблюдателя. 5 Для построения матрицы должны быть заданы следующие величины: − позиция камеры в мировом пространстве (𝑒𝑦𝑒); − позиция цели, на которую направлена камера (𝑡𝑎𝑟𝑔𝑒𝑡); − вектор, направленный вертикально вверх с точки зрения камеры (𝑢𝑝). Далее необходимо вычислить базисные векторы камеры: 𝑍𝐴𝑥𝑖𝑠 = 𝑛𝑜𝑟𝑚𝑎𝑙𝑖𝑧𝑒(𝑒𝑦𝑒 − 𝑡𝑎𝑟𝑔𝑒𝑡), 𝑋𝐴𝑥𝑖𝑠 = 𝑛𝑜𝑟𝑚𝑎𝑙𝑖𝑧𝑒(𝑢𝑝 × 𝑍𝐴𝑥𝑖𝑠), 𝑌𝐴𝑥𝑖𝑠 = 𝑢𝑝. (1.7) Итоговая матрица будет выглядеть следующим образом: [ 𝑋𝐴𝑥𝑖𝑠𝑥 𝑋𝐴𝑥𝑖𝑠𝑦 𝑋𝐴𝑥𝑖𝑠𝑧 −(𝑋𝐴𝑥𝑖𝑠 ⋅ 𝑒𝑦𝑒) 𝑌𝐴𝑥𝑖𝑠𝑥 𝑌𝐴𝑥𝑖𝑠𝑦 𝑌𝐴𝑥𝑖𝑠𝑧 −(𝑌𝐴𝑥𝑖𝑠 ⋅ 𝑒𝑦𝑒) 𝑍𝐴𝑥𝑖𝑠𝑥 𝑍𝐴𝑥𝑖𝑠𝑦 𝑍𝐴𝑥𝑖𝑠𝑧 −(𝑍𝐴𝑥𝑖𝑠 ⋅ 𝑒𝑦𝑒) 0 0 0 1 ] . (1.8) С помощью данной матрицы все объекты сцены получат новые коорди- наты в пространстве, центром которого является позиция камеры. 4) Реализовать матричное преобразование координат из пространства наблюдателя в пространство проекции Сцена теперь находится в пространстве, которое удобно проецировать. Все, что теперь нужно сделать, это спроецировать его на воображаемый экран камеры. Прежде чем сделать изображение плоским, необходимо перейти в другое, последнее пространство, пространство проекции. Это пространство является кубоидом, размеры которого находятся между значениями -1 и 1 для осей X и Y и между значениями 0 и 1 для оси Z. Это пространство очень удобно для отсечения (все, что находится за пределами диапазона от -1 до 1 и от 0 до 1, находится за пределами области просмотра камеры) и упрощает опе- рацию проецирования (нужно просто отбросить значение 𝑧, чтобы получить плоское изображение). Чтобы перейти из пространства наблюдателя в пространство проециро- вания, нужна другая матрица — матрица преобразования из пространства наблюдателя в пространство проекции. Значения этой матрицы зависят от того, какой тип проекции необходимо выполнить. Двумя наиболее часто ис- пользуемыми проекциями являются ортографическая проекция и перспектив- ная проекция. 6 Чтобы сделать ортографическую проекцию, нужно определить размер области, которую может видеть камера. Обычно он задается значениями ши- рины и высоты для оси X и Y и значениями ближнего и дальнего 𝑧 для оси Z. Учитывая эти значения, можно создать матрицу преобразования, кото- рая преобразует область прямоугольника в кубоид. Следующая матрица пре- образует векторы из пространства наблюдателя в пространство ортографиче- ской проекции и предполагает правостороннюю систему координат: [ 2 𝑤𝑖𝑑𝑡ℎ 0 0 0 0 2 ℎ𝑒𝑖𝑔ℎ𝑡 0 0 0 0 1 𝑧𝑛𝑒𝑎𝑟 − 𝑧𝑓𝑎𝑟 𝑧𝑛𝑒𝑎𝑟 𝑧𝑛𝑒𝑎𝑟 − 𝑧𝑓𝑎𝑟 0 0 0 1 ] , (1.9) где 𝑤𝑖𝑑𝑡ℎ — ширина обзора камеры; ℎ𝑒𝑖𝑔ℎ𝑡 — высота обзора камеры; 𝑧𝑛𝑒𝑎𝑟 — расстояние до ближней плоскости обзора камеры; 𝑧𝑓𝑎𝑟 — расстояние до дальней плоскости обзора камеры. Другой проекцией является перспективная проекция. Идея похожа на орфографическую проекцию, но на этот раз область просмотра является усе- ченной пирамидой, и поэтому преобразования немного сложнее. К сожале- нию, матричного умножения в этом случае недостаточно, потому что после умножения на матрицу результат не находится в одном и том же пространстве проекции (что означает, что w-компонент не равен 1 для каждой вершины). Чтобы завершить преобразование, нужно разделить каждую компоненту век- тора на компонент 𝑤. Современные графические API выполняют деление ав- томатически, поэтому можно просто умножить все вершины на матрицу пер- спективной проекции и отправить результат на графический процессор. [ 2 ∙ 𝑧𝑛𝑒𝑎𝑟 𝑤𝑖𝑑𝑡ℎ 0 0 0 0 2 ∙ 𝑧𝑛𝑒𝑎𝑟 ℎ𝑒𝑖𝑔ℎ𝑡 0 0 0 0 𝑧𝑓𝑎𝑟 𝑧𝑛𝑒𝑎𝑟 − 𝑧𝑓𝑎𝑟 𝑧𝑛𝑒𝑎𝑟 ∙ 𝑧𝑓𝑎𝑟 𝑧𝑛𝑒𝑎𝑟 − 𝑧𝑓𝑎𝑟 0 0 −1 0 ] . (1.10) Также существует другая форма матрицы перспективной проекции, ис- пользующая угол обзора камеры: 7 [ 1 𝑎𝑠𝑝𝑒𝑐𝑡 ∙ tan ( 𝐹𝑂𝑉 2 ) 0 0 0 0 1 tan ( 𝐹𝑂𝑉 2 ) 0 0 0 0 𝑧𝑓𝑎𝑟 𝑧𝑛𝑒𝑎𝑟 − 𝑧𝑓𝑎𝑟 𝑧𝑛𝑒𝑎𝑟 ∙ 𝑧𝑓𝑎𝑟 𝑧𝑛𝑒𝑎𝑟 − 𝑧𝑓𝑎𝑟 0 0 −1 0 ] , (1.11) где 𝐹𝑂𝑉 — поле зрение камеры по оси Y; 𝑎𝑠𝑝𝑒𝑐𝑡 — соотношение сторон обзора камеры. 5) Реализовать матричное преобразование координат из пространства проекции в пространство окна просмотра Окно просмотра — это область в окне приложения, в которой отобража- ется визуализируемая сцена. Оно может занимать всю область окна приложе- ния или его часть. Т.к. экранная ось Y направлена вниз (начало координат находится в верхнем левом углу экрана), ее необходимо перевернуть. Чтобы адаптировать размеры проекции под размеры окна просмотра, учесть направление оси Y экрана и переместить начало координат в центр окна просмотра, необходимо воспользоваться следующей матрицей: [ 𝑤𝑖𝑑𝑡ℎ 2 0 0 𝑥𝑚𝑖𝑛 + 𝑤𝑖𝑑𝑡ℎ 2 0 − ℎ𝑒𝑖𝑔ℎ𝑡 2 0 𝑦𝑚𝑖𝑛 + ℎ𝑒𝑖𝑔ℎ𝑡 2 0 0 1 0 0 0 0 1 ] , (1.12) Стоит учитывать, что соотношение сторон проекции и соотношение сто- рон окна просмотра должны совпадать, иначе итоговое изображение будет растянуто или сжато внутри окна просмотра. Наконец, модель может быть преобразована для отображения с помо- щью цепочки [𝑉𝑖𝑒𝑤𝑝𝑜𝑟𝑡] × [𝑃𝑟𝑜𝑗𝑒𝑐𝑡𝑖𝑜𝑛] × [𝑉𝑖𝑒𝑤] × [𝑀𝑜𝑑𝑒𝑙]. 8 6) Реализовать отрисовку проволочной 3D модели После того как были преобразованы все координаты вершин, необхо- димо нарисовать линии, соединяющие соответствующие вершины полигонов. Для этого можно использовать следующие алгоритмы: − алгоритм DDA-линии; − алгоритм Брезенхема. Алгоритм DDA-линии Пусть отрезок задан координатами концов (𝑥1, 𝑦1); (𝑥2, 𝑦2). Большее по абсолютной величине число, (𝑥2 − 𝑥1) или (𝑦2 − 𝑦1), принимается за количе- ство шагов 𝐿 цикла растеризации. На каждом шаге цикла значение функции и ее аргумента получают приращения (𝑥2 − 𝑥1) 𝐿⁄ ; (𝑦2 − 𝑦1) 𝐿⁄ . Растровые ко- ординаты отрезка получаются в результате округления соответствующих 𝑥 и 𝑦, полученных на каждом шаге цикла растеризации. Алгоритм Брезенхема В процессе растеризации линии можно заметить, что на каждом шаге цикла происходит одно из двух: значение 𝑦 остается неизменным либо увели- чивается на 1. Выбор производится на основе значения ошибки, которое озна- чает вертикальное расстояние между текущим значением 𝑦 и точным значе- нием функции для текущего 𝑥. Всякий раз, когда мы увеличиваем 𝑥, мы уве- личиваем значение ошибки на величину наклона 𝑠 = 𝑦2−𝑦1 𝑥2−𝑥1. Если ошибка пре- высила 0.5, линия стала ближе к следующему 𝑦, поэтому нужно увеличить 𝑦 на единицу, а значение ошибки уменьшить на 1. В данном алгоритме значение ошибки, величина наклона 𝑠, а также кон- станта 0.5 являются числами с плавающей запятой. Чтобы ускорить вычисле- ния, необходимо перейти к целым числам. Это можно сделать, если умножить все используемые вещественные величины на (𝑥2 − 𝑥1). Тогда на каждом шаге цикла значение ошибки будет увеличиваться на (𝑦2 − 𝑦1), а при увеличении 𝑦 на 1 значение ошибки будет уменьшаться на (𝑥2 − 𝑥1). Чтобы избавиться от константы 0.5, необходимо умножить обе части неравенства на 2, тогда вместо 𝑒𝑟𝑟𝑜𝑟 > 0.5 × (𝑥2 − 𝑥1) получится 2 × 𝑒𝑟𝑟𝑜𝑟 > (𝑥2 − 𝑥1). 9 ЛАБОРАТОРНАЯ РАБОТА №2 1) Реализовать алгоритм растеризации треугольников Для отображения заполненного треугольника на экране необходимо найти координаты всех точек, которые попадут в область треугольника, огра- ниченную тремя его ребрами. Процесс нахождения координат этих точек называется растеризацией. Одним из алгоритмов растеризации треугольников является метод ска- нирующей линии, где горизонтальная линия перемещается вниз от самой верх- ней вершины треугольника до самой нижней. На каждом этапе алгоритма находятся координаты точек пересечения ребер треугольника со сканирующей линией, а затем производится рисование горизонтальной линии между найден- ными координатами. Для нахождения точек пересечения и рисования горизон- тальной линии можно воспользоваться алгоритмами, реализованными в предыдущей лабораторной работе. 2) Реализовать отбраковку невидимых и задних поверхностей трехмерных объектов В процессе растеризации некоторые задние грани объекта могут быть нарисованы поверх передних граней. Для решения этой проблемы использу- ется Z-буфер, который хранит глубину нарисованных фрагментов. При рисо- вании нового фрагмента нужно сравнить значение глубины этого фрагмента со значением глубины нарисованного в той же позиции фрагмента в Z-буфере. Если значение глубины нового фрагмента меньше значения глубины в Z- буфере (фрагмент находится ближе к наблюдателю), то значение глубины в Z- буфере заменяется значением глубины нового фрагмента. В противном случае новый фрагмент не рисуется. Для ускорения отрисовки объектов можно использовать отбраковку по- верхностей, которые не видны из-за их ориентации. Это все треугольники с нормалью, которая смотрит почти в том же направлении, что и зритель. Если скалярное произведение вектора нормали и вектора взгляда отрицательное, то такой треугольник можно отбросить. Чтобы найти нормаль к поверхности тре- угольника, необходимо вычислить векторное произведение двух его смежных ребер. Если на экране вершины треугольника перечислены по часовой стрелке, то вектор нормали будет направлен по направлению взгляда, следовательно такой треугольник можно отбраковать. 10 3) Реализовать плоское затенение и модель освещения Ламберта Простейшей моделью затенения является «постоянное затенение», также известное как «граненое затенение» или «плоское затенение». Этот под- ход применяет модель освещения один раз, чтобы определить одно значение интенсивности, которое затем используется для затенения целого полигона. Идея алгоритма плоского затенения довольна простая. Сначала вычис- ляется цвет в каждой вершине треугольника, затем полученные значения усредняются, и весь треугольник закрашивается в полученный цвет. При ис- пользовании этой модели не возникает трудностей, когда нормали заданы для граней, а не для вершин. В этом случае цвет треугольника можно рассчитывать в его геометрическом центре. Чтобы вычислить интенсивность света для всего полигона, можно вос- пользоваться моделью освещения Ламберта, которая является простейшей мо- делью освещения (рисунок 2.1). Для этого нужно найти скалярное произведе- ние вектора нормали и обратного вектора направления света. Полученный ре- зультат будет являться косинусом угла между этими векторами. Чем меньше угол между векторами, тем больше косинус угла, тем сильнее свет освещает поверхность. Рисунок 2.1 — Схема модели освещения Ламберта 11 ЛАБОРАТОРНАЯ РАБОТА №3 1) Реализовать модель затенения по Фонгу В отличие от плоского затенения, в этой модели освещение не усредня- ется для грани, а линейно интерполируется между вершинами, поэтому для данной модели важно то, что нормали задаются в вершинах. Этот алгоритм позволяет получить гораздо более приятное изображение, чем при использо- вании алгоритма плоского затенения, но требует гораздо больше вычислитель- ных ресурсов. Модели обычно задаются набором плоских выпуклых граней, хотя боль- шинство реальных трехмерных предметов имеют гладкие криволинейные по- верхности. Таким образом, криволинейная поверхность рисуется как ребри- стая полигональная сетка. Для того, чтобы эта сетка выглядела гладкой, ис- пользуется тот или иной метод интерполяции освещенности вершин полиго- нальной сетки. Если используется затенение по Гуро, то расчет цвета производится в каждой вершине каждой грани, а затем рассчитанный цвет интерполируется по всей грани. В результате блики, которые должны проявиться в середине полигона, нарисованы не будут — при интерполяции цветов вершин более яр- кое освещение центра многоугольника невозможно. При затенении по Фонгу между вершинами интерполируется не цвет, а нормаль. Цвет, в свою очередь, рассчитывается для каждого пикселя в отдель- ности. Если нормали вершин не заданы в сетке и не могут быть определены непосредственно с реальной поверхности, то их можно аппроксимировать пу- тем усреднения нормалей поверхности всех полигонов, разделяющих одну вершину. Если ребро должно быть видимым (как на стыке между крылом и корпусом самолета), то следует найти две вершинные нормали, по одной для каждой стороны ребра, путем усреднения нормалей полигонов отдельно на каждой стороне ребра. 2) Реализовать модель освещения по Фонгу Освещение в реальном мире чрезвычайно сложно и зависит от слишком многих факторов, что невозможно вычислить на ограниченной производи- тельности, которая имеется на сегодняшний день. Модель освещения по Фонгу основана на физике света в реальной жизни и используется для созда- ния реалистичного изображения. Освещение по Фонгу состоит из трех 12 компонентов: фонового, рассеянного и бликового освещения. На рисунке 3.1 показано, как выглядят эти компоненты. Рисунок 3.1 — Компоненты освещения по Фонгу Фоновое освещение: даже когда темно, обычно где-то в мире присут- ствует какой-то свет (луна, дальний свет), поэтому объекты почти никогда не становятся абсолютно черными. Чтобы имитировать это освещение, исполь- зуется постоянная освещенность, которая всегда придает объекту некоторый цвет (слева на рисунке 3.1). Рассеянное освещение: имитирует направленное воздействие, которое источник света оказывает на объект. Это самый визуально значимый компо- нент модели освещения. Чем больше объект обращен к источнику света, тем ярче он становится (второе слева на рисунке 3.1). Зеркальное освещение: имитирует яркое пятно света, которое появля- ется на блестящих объектах. Зеркальные блики часто имеют цвет света, а не цвет объекта (второе справа на рисунке 3.1). Чтобы создать визуально интересные сцены, необходимо имитировать, по крайней мере, эти три компонента освещения. Фоновое освещение Свет обычно исходит не от одного источника света, а от многих источ- ников света, расположенных вокруг, даже когда они не видны. Одним из свойств света является то, что он может рассеиваться и отражаться во многих направлениях, достигая объектов, которые не находятся в непосредственной близости. Таким образом, свет может отражаться от других поверхностей и оказывать косвенное влияние на освещение объекта. Алгоритмы, которые при- нимают это во внимание, называются глобальными алгоритмами освещения, но они трудоемкие и / или сложные. Поскольку расчет фонового освещения требует больших вычислитель- ных ресурсов, что неприемлемо, необходимо использовать очень упрощенную модель глобального освещения, а именно фонового освещения. Для этого 13 используется небольшой постоянный (светлый) цвет, который добавляется к окончательному цвету фрагментов объекта, что имитирует постоянное при- сутствие отраженного света, даже если нет прямого источника света. Добавление фонового освещения на сцену очень просто. Цвет фонового света умножается на небольшой постоянный коэффициент фонового освеще- ния: 𝐼𝑎 = 𝑘𝑎 ∙ 𝑖𝑎, (3.1) где 𝐼𝑎 — значение фонового освещения; 𝑘𝑎 — коэффициент фонового освещения; 𝑖𝑎 — цвет фонового света. Рассеянное освещение Фоновое освещение само по себе не дает интересных результатов, но рассеянное освещение оказывает значительное визуальное воздействие на объект. Рассеянное освещение дает объекту большую яркость, чем ближе его фрагменты повернуты к лучу света, испускаемого источником света. На ри- сунке 2.1 представлено схематическое описание рассеянного света. Слева находится источник света с лучом света, нацеленным на один из фрагментов объекта. Затем нужно измерить, под каким углом световой луч па- дает на фрагмент. Если луч света перпендикулярен к поверхности объекта, свет оказывает наибольшее влияние. Чтобы измерить угол между лучом света и фрагментом, используется вектор нормали, который перпендикулярен по- верхности фрагмента. Тогда угол между двумя векторами можно легко вычис- лить с помощью скалярного произведения. Важным свойством скалярного произведения является то, что чем ниже угол между двумя единичными векторами, тем больше скалярное произведе- ние стремится к значению 1. Когда угол между обоими векторами равен 90 градусам, скалярное произведение становится 0. То же самое относится и к 𝜃: чем больше становится угол, тем меньше влияние света на цвет фрагмента. Следует отметить, что для получения (только) косинуса угла между обо- ими векторами необходимо работать с единичными векторами (векторами с длиной, равной 1), поэтому нужно убедиться, что все векторы нормированы, в противном случае скалярное произведение будет возвращать больше, чем про- сто косинус. Таким образом, полученное скалярное произведение возвращает скаляр, который можно использовать для вычисления влияния света на цвет фраг- мента, что приводит к фрагментам разной освещенности в зависимости от их ориентации относительно света. 14 Чтобы найти воздействие рассеянного света на текущий фрагмент, нужно посчитать скалярное произведение нормали и вектора света. Получен- ное значение затем умножается на цвет рассеянного света и на коэффициент рассеянного освещения, в результате чего получается более темный фрагмент, если между обоими векторами большой угол. 𝐼𝑑 = 𝑘𝑑 ∙ (𝑁 ∙ 𝐿) ∙ 𝑖𝑑, (3.2) где 𝐼𝑑 — значение рассеянного освещения; 𝑘𝑑 — коэффициент рассеянного освещения; 𝑖𝑑 — цвет рассеянного света. Если угол между обоими векторами больше 90 градусов, то результат скалярного произведения будет отрицательным, и рассеянная составляющая также будет отрицательной. По этой причине отрицательные значения всегда приравниваются к нулю (т.е. поверхность не освещается). Освещение для от- рицательных значений не определено, поэтому этого лучше избегать. Зеркальное освещение Подобно рассеянному освещению, зеркальное освещение зависит от вектора направления света и от векторов нормалей объекта, но на этот раз оно также зависит и от направления взгляда. Зеркальное освещение основано на отражающих свойствах света. Если объект имеет зеркальную поверхность, то зеркальное освещение достигает максимального эффекта, независимо от по- ложения света, отраженного от поверхности. Этот эффект можно увидеть на рисунке 3.2. Рисунок 3.2 — Схема зеркального освещения Чтобы вычислить вектор отражения, нужно отразить направление света относительно вектора нормали. Затем вычисляется угловое расстояние между этим вектором отражения и направлением взгляда, и чем меньше угол между 15 ними, тем больше влияние зеркального света. В результате получается эффект, при котором на поверхности объекта образуется светлый блик, который явля- ется отраженным от поверхности светом, попавшим в объектив камеры или глаз человека. Вектор взгляда — это одна дополнительная переменная, которая нужна для нахождения зеркального освещения и которую можно вычислить, исполь- зуя положение наблюдателя и положение фрагмента в мировом пространстве. Иногда для вычисления освещения используют мировое пространство, но большинство людей предпочитает рассчитывать освещение в пространстве наблюдателя. Дополнительным преимуществом вычислений в пространстве наблюдателя является то, что позиция наблюдателя всегда находится в (0, 0, 0), поэтому не нужно находить эту позицию. Тем не менее, подсчет освещения в мировом пространстве более понятен. Если необходимо рассчитать освеще- ние в пространстве наблюдателя, то нужно преобразовать все соответствую- щие векторы с помощью матрицы наблюдателя (а также векторы нормалей). Теперь, когда есть все необходимые переменные, можно вычислить ин- тенсивность зеркального освещения, используя следующую формулу: 𝐼𝑠 = 𝑘𝑠 ∙ (𝑅 ∙ 𝑉)∝ ∙ 𝑖𝑠, (3.3) где 𝐼𝑠 — значение зеркального освещения; 𝑘𝑠 — коэффициент зеркального освещения; ∝ — коэффициент блеска поверхности; 𝑖𝑠 — цвет зеркального света. Сначала вычисляется скалярное произведение вектора взгляда и вектора отражения (результат должен быть неотрицательным), а затем результат воз- водится в степень ∝. Чем выше коэффициент блеска поверхности, тем лучше она отражает свет и хуже рассеивает его, и тем самым отраженный блик ста- новится меньше. Чтобы найти вектор отраженного луча света, можно воспользоваться следующей формулой: 𝑅 = 𝐿 − 2 ∙ (𝐿 ∙ 𝑁) ∙ 𝑁. (3.4) Совмещение компонентов освещения После того как были вычислены все основные компоненты освещения, можно воспользоваться итоговой формулой для расчета конечного цвета фраг- мента: 𝐼 = 𝐼𝑎 + 𝐼𝑑 + 𝐼𝑠. (3.5) 16 ЛАБОРАТОРНАЯ РАБОТА №4 В данной лабораторной работе необходимо реализовать алгоритмы наложения текстур различных типов на трехмерные объекты. Текстуры представляют собой двухмерные массивы данных, например, данные цвета, данные яркости или данные прозрачности. Отдельные пиксели текстуры часто называют текселями. Важной особенностью текстурирования является то, что прямоугольная текстура может быть применена к непрямо- угольным областям. На рисунке 4.1 показан процесс наложения текстуры. Левая часть ри- сунка представляет всю текстуру, а салатовый контур на ней представляет со- бой пятиугольную фигуру, на которую нужно наложить эту текстуру. Когда пятиугольник отображается на экране, он может быть искажен после приме- нения различных преобразований — вращения, перемещения, масштабирова- ния и проецирования. На правой части рисунка показано, как пятиугольник с текстурой отобразится на экране после этих преобразований. Рисунок 4.1 — Процесс наложения текстуры Можно заметить, как текстура искажается в соответствии с искажением пятиугольника. В данном случае он сжат в направлении X, а также немного повернут. Для наложения текстуры требуется, чтобы для каждой вершины поли- гона были заданы текстурные координаты. Эти координаты не зависят от раз- меров текстуры (имеют значения в диапазоне от 0 до 1) и задают каждой вер- шине полигона соответствующие тексели текстуры. Для заполнения полигона текселями используются такие же алгоритмы, как и при растеризации 17 треугольников. Но вместо нахождения координат фрагментов, заполняющих треугольник, нужно найти текстурные координаты для каждого фрагмента, интерполируя текстурные координаты, заданные в вершинах треугольника. 1) Реализовать алгоритм наложения диффузной карты Диффузная карта задает основной цвет поверхности объекта (способ- ность объекта рассеивать определенный спектр падающего на него света). Каждому фрагменту поверхности назначаются собственные значения коэффи- циентов фонового (𝑘𝑎) и рассеянного (𝑘𝑑) освещения, полученных из соответ- ствующего текселя диффузной карты. Данный тип текстур очень важен и ис- пользуется повсеместно для создания фотореалистичной графики. На рисунке 4.2 представлен пример диффузной карты. Рисунок 4.2 — Пример диффузной текстуры 2) Реализовать алгоритм наложения карты нормалей Затенение по Фонгу позволяет создавать плавное освещение поверхно- стей, используя линейное интерполирование нормалей вершин полигона. Тем не менее, для создания более реалистичного изображения можно использовать текстуры, называемые картами нормалей. В таких картах в каждом текселе текстуры заданы нормали к соответствующим фрагментам поверхности. Та- кой подход позволяет визуализировать объекты с малым числом полигонов, 18 но с высокой детализацией, что увеличивает скорость рендеринга по сравне- нию с объектами, имеющими большое число полигонов. В то время как векторы нормалей являются геометрическими объектами, текстуры обычно используются только для хранения информации о цвете, по- этому хранение нормалей в текстуре может быть неочевидным. Цвет в тек- стуре представлен вектором с компонентами R, G и B. Аналогичным образом можно сохранить компоненты X, Y и Z вектора нормали в соответствующих цветовых компонентах. Т.к. компоненты вектора нормали находятся в диапазоне от -1 до 1, а компоненты цвета текстуры — от 0 до 1, требуется преобразовать значение цвета в значение вектора: 𝑁 =∥ 𝐶𝑡 ∙ 2 − 1 ∥, (4.1) где 𝐶𝑡 — цвет текстуры. Существует две разновидности карт нормалей. На рисунке 4.3 слева представлена карта нормалей, векторы которой находятся в пространстве мо- дели, поэтому эта текстура имеет разноцветный вид, т.к. все векторы могут смотреть в абсолютно любом направлении. Справа на рисунке показана карта нормалей, у которой все векторы находятся в пространстве плоскости поли- гона (в касательном пространстве). Эта карта имеет синий оттенок. Это свя- зано с тем, что все нормали смотрят в положительном направлении оси Z, ко- торая равна (0, 0, 1) (синий цвет). Карта нормалей в касательном пространстве очень подходит для создания анимации, т.к. для каждого состояния объекта потребовалась бы отдельная карта нормалей в пространстве модели. Однако существует одна проблема, которая сильно ограничивает ис- пользование карт нормалей в касательном пространстве. Требуется преобра- зовать нормали таким образом, чтобы полученные векторы смотрели в том же направлении, что и плоскость полигона (т.е. нужно перейти из касательного пространства в мировое пространство). Другое решение заключается в том, чтобы перенести освещение и камеру в касательное пространство, а векторы нормалей оставить неизменными. Таким образом, можно использовать одну и ту же карту нормалей, независимо от ориентации объекта. В данной лабораторной работе необходимо реализовать алгоритм нало- жения карты нормалей, векторы которой находятся в пространстве модели (слева на рисунке 4.3). 19 Рисунок 4.3 — Разновидности карт нормалей 3) Реализовать алгоритм наложения зеркальной карты Зеркальная карта содержит данные о способности объекта отражать свет. В большинстве случаев данная текстура является черно-белой модифи- кацией диффузной карты. Каждый тексель зеркальной карты содержит коэф- фициент зеркального освещения (𝑘𝑠) для соответствующего фрагмента по- верхности. На рисунке 4.4 представлен пример зеркальной карты. Рисунок 4.4 — Пример зеркальной карты 20 4) Реализовать алгоритм интерполяции атрибутов вершин с перспективной коррекцией Аффинное наложение текстур линейно интерполирует текстурные коор- динаты по поверхности и является самым быстрым методом текстурирования. Поскольку данный способ не учитывает информацию о глубине фрагмента, в ситуации, когда поверхность расположена под углом к наблюдателю, можно заметить искажение текстуры (рисунок 4.5). Наложение текстур с перспективной коррекцией учитывает положение фрагмента в трехмерном пространстве, а не просто интерполирует координаты в двухмерном пространстве экрана. Это позволяет достичь правильного отоб- ражение текстуры, но требует больше вычислительного времени. Рисунок 4.5 — Различие в способах наложения текстур При аффинном наложении текстур текстурные координаты вершин ли- нейно интерполируются по формуле: 𝑢𝑣𝑡 = (1 − 𝑡) ⋅ 𝑢𝑣0 + 𝑡 ⋅ 𝑢𝑣1, (4.2) где 𝑡 — коэффициент интерполяции. При наложении текстур с перспективной коррекцией текстурные коор- динаты вершин линейно интерполируются после деления на глубину 𝑧, а затем полученное значение делится на интерполированное обратное значение глу- бины: 𝑢𝑣𝑡 = (1 − 𝑡) ⋅ 𝑢𝑣0 𝑧0 + 𝑡 ⋅ 𝑢𝑣1 𝑧1 (1 − 𝑡) ⋅ 1 𝑧0 + 𝑡 ⋅ 1 𝑧1 . (4.3)","libVersion":"0.2.3","langs":""}